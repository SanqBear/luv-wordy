//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class DictionariesClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * 단어 목록을 가져옵니다
   * @param page (optional) 페이지 번호
   * @param size (optional) 가져올 아이템 수
   * @param offset (optional) 건너 뛸 아이템 수 (페이지보다 우선함)
   * @return 단어 목록 및 총 아이템 수를 반환
   */
  getDictionaries(
    page: number | undefined,
    size: number | undefined,
    offset: number | undefined
  ): Promise<WordItemSummaryApiPagedResult> {
    let url_ = this.baseUrl + "/api/v1.0/dictionaries?";
    if (page === null) throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "page=" + encodeURIComponent("" + page) + "&";
    if (size === null) throw new Error("The parameter 'size' cannot be null.");
    else if (size !== undefined)
      url_ += "size=" + encodeURIComponent("" + size) + "&";
    if (offset === null)
      throw new Error("The parameter 'offset' cannot be null.");
    else if (offset !== undefined)
      url_ += "offset=" + encodeURIComponent("" + offset) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetDictionaries(_response);
    });
  }

  protected processGetDictionaries(
    response: Response
  ): Promise<WordItemSummaryApiPagedResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as WordItemSummaryApiPagedResult);
        return result200;
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException(
          "\uc624\ub958 \ubc1c\uc0dd",
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<WordItemSummaryApiPagedResult>(null as any);
  }

  /**
   * 특정 ID의 단어들을 가져옵니다. (동음이의어 포함)
   * @param id 단어 ID
   * @param definitionId (optional) 정의 ID
   * @return 단어를 반환
   */
  getDictionary(
    id: string,
    definitionId: string | undefined
  ): Promise<GuidWordItemDictionaryApiResult> {
    let url_ = this.baseUrl + "/api/v1.0/dictionaries/{id}?";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (definitionId === null)
      throw new Error("The parameter 'definitionId' cannot be null.");
    else if (definitionId !== undefined)
      url_ += "definitionId=" + encodeURIComponent("" + definitionId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetDictionary(_response);
    });
  }

  protected processGetDictionary(
    response: Response
  ): Promise<GuidWordItemDictionaryApiResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as GuidWordItemDictionaryApiResult);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException(
          "ID\ub97c \ud30c\uc2f1\ud560 \uc218 \uc5c6\uc74c",
          status,
          _responseText,
          _headers
        );
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException(
          "\uc624\ub958 \ubc1c\uc0dd",
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<GuidWordItemDictionaryApiResult>(null as any);
  }

  /**
   * 단어 목록을 검색합니다
   * @param page (optional) 페이지 번호
   * @param size (optional) 가져올 아이템 수
   * @param offset (optional) 건너 뛸 아이템 수 (페이지보다 우선함)
   * @param body (optional) 검색 파라메터
   * @return 색인된 단어 목록 및 총 아이템 수를 반환
   */
  searchDictionary(
    page: number | undefined,
    size: number | undefined,
    offset: number | undefined,
    body: DictionarySearchParams | undefined
  ): Promise<WordItemSummaryApiPagedResult> {
    let url_ = this.baseUrl + "/api/v1.0/dictionaries/search?";
    if (page === null) throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "page=" + encodeURIComponent("" + page) + "&";
    if (size === null) throw new Error("The parameter 'size' cannot be null.");
    else if (size !== undefined)
      url_ += "size=" + encodeURIComponent("" + size) + "&";
    if (offset === null)
      throw new Error("The parameter 'offset' cannot be null.");
    else if (offset !== undefined)
      url_ += "offset=" + encodeURIComponent("" + offset) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSearchDictionary(_response);
    });
  }

  protected processSearchDictionary(
    response: Response
  ): Promise<WordItemSummaryApiPagedResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as WordItemSummaryApiPagedResult);
        return result200;
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException(
          "\uc624\ub958 \ubc1c\uc0dd",
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<WordItemSummaryApiPagedResult>(null as any);
  }
}

/** 활용 모델 */
export interface ConjugationItem {
  /** 발음 ID */
  id?: string;
  /** 발음 */
  pronunciation?: string | null;
  /** 발음 음성 URL */
  soundUrl?: string | null;
  /** 표기 시, 단어의 모양 */
  writtenForm?: string | null;
}

/** 사전 검색 파라메터 */
export interface DictionarySearchParams {
  keyword?: string | null;
  lexicalUnit?: string | null;
  partOfSpeech?: string | null;
  vocabularyLevel?: string | null;
}

export interface GuidWordItemDictionaryApiResult {
  /** 작업 성공 여부. API 콜 응답성공여부는 HTTP ResponseCode 로 응답 */
  success?: boolean;
  /** 오류 메시지 */
  message?: string | null;
  /** 데이터 */
  data?: { [key: string]: WordItem } | null;
}

export enum LexicalUnitType {
  Unknown = "Unknown",
  Word = "Word",
  Phrase = "Phrase",
  Idiom = "Idiom",
  Proverb = "Proverb",
  Expression = "Expression",
  NotInterested = "NotInterested",
}

export enum PartOfSpeechType {
  Unknown = "Unknown",
  Noun = "Noun",
  Verb = "Verb",
  Pronoun = "Pronoun",
  Adjective = "Adjective",
  DependentNoun = "DependentNoun",
  AuxiliaryVerb = "AuxiliaryVerb",
  Numerals = "Numerals",
  Postposition = "Postposition",
  Affix = "Affix",
  Adverb = "Adverb",
  Interjection = "Interjection",
  Detective = "Detective",
  AuxiliaryAdjective = "AuxiliaryAdjective",
  Termination = "Termination",
  None = "None",
  NotInterested = "NotInterested",
}

/** 발음 모델 */
export interface PronunciationItem {
  /** 발음 ID */
  id?: string;
  /** 발음 */
  pronunciation?: string | null;
  /** 발음 음성 URL */
  soundUrl?: string | null;
}

export enum VocabularyLevelType {
  Unknown = "Unknown",
  None = "None",
  Easy = "Easy",
  Normal = "Normal",
  Hard = "Hard",
  NotInterested = "NotInterested",
}

/** 단어 모델 */
export interface WordItem {
  /** 한국어 기초 사전 기준 ID 컬럼 (중복값이 존재하므로, 참조용으로 사용) */
  dataNumber?: number;
  /** 표기 시, 단어의 모양 */
  writtenForm?: string | null;
  /** 단어 ID */
  id?: string;
  /** 단어의 정의 ID */
  definitionId?: string;
  /** 동음이의어의 개수 */
  homonymNumber?: number;
  /** 어휘의 단위 (DB 저장 값) */
  lexicalUnitText?: string | null;
  /** 품사 (DB 저장 값) */
  partOfSpeechText?: string | null;
  /** 표현의 난이도 (DB 저장 값) */
  vocabularyLevelText?: string | null;
  lexicalUnit?: LexicalUnitType;
  partOfSpeech?: PartOfSpeechType;
  vocabularyLevel?: VocabularyLevelType;
  /** 단어의 정의 */
  definition?: string | null;
  /** 단어의 발음 */
  readonly pronunciations?: PronunciationItem[] | null;
  /** 단어의 활용 */
  readonly conjugations?: ConjugationItem[] | null;
  /** 표제어 존재 여부 */
  readonly hasEntryWord?: boolean;
  entryWord?: WordItemBase;
}

/** 단어. 약식 (참조용) */
export interface WordItemBase {
  /** 한국어 기초 사전 기준 ID 컬럼 (중복값이 존재하므로, 참조용으로 사용) */
  dataNumber?: number;
  /** 표기 시, 단어의 모양 */
  writtenForm?: string | null;
}

/** 단어. 요약 (목록용) */
export interface WordItemSummary {
  /** 한국어 기초 사전 기준 ID 컬럼 (중복값이 존재하므로, 참조용으로 사용) */
  dataNumber?: number;
  /** 표기 시, 단어의 모양 */
  writtenForm?: string | null;
  /** 단어 ID */
  id?: string;
  /** 단어의 정의 ID */
  definitionId?: string;
  /** 동음이의어의 개수 */
  homonymNumber?: number;
  /** 어휘의 단위 (DB 저장 값) */
  lexicalUnitText?: string | null;
  /** 품사 (DB 저장 값) */
  partOfSpeechText?: string | null;
  /** 표현의 난이도 (DB 저장 값) */
  vocabularyLevelText?: string | null;
  lexicalUnit?: LexicalUnitType;
  partOfSpeech?: PartOfSpeechType;
  vocabularyLevel?: VocabularyLevelType;
}

export interface WordItemSummaryApiPagedResult {
  /** 작업 성공 여부. API 콜 응답성공여부는 HTTP ResponseCode 로 응답 */
  success?: boolean;
  /** 오류 메시지 */
  message?: string | null;
  /** 데이터 (List) */
  data?: WordItemSummary[] | null;
  /** 총 아이템 수 */
  totalCount?: number;
  /** Offset 이후로 Item이 더 있는지 */
  readonly moreAvailable?: boolean;
  /** 다음 Offset */
  nextOffset?: number | null;
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
